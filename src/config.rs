use std::path::Path;
use anyhow::anyhow;
use mlua::Value;
use regex::Regex;
use goat_lua::GoatLua;

/// `goat`'s configuration file specification.
/// 
/// Here lies every configuration option
/// for the goat system.
pub struct Config {
    /// The system's hostname. `systemd` systems define this as 
    /// `/etc/hostname` and provides `hostnamectl`. For this
    /// we will stick with `/etc/hostname` for portability.
    /// 
    /// We default this to "goatOS" later.
    pub hostname: String,

    /// The list of packages the user explicitly wants installed.
    /// Dependency packages will be pulled in implicitly by their package
    /// manager.
    pub packages: Option<Vec<String>>
}

impl Default for Config {
    fn default() -> Self {
        Config {
            hostname: String::from("goatOS"),
            packages: None
        }
    }
}

impl Config {
    /// Create a `Config` instance from a file path.
    pub fn from_file(path: &Path) -> anyhow::Result<Self> {
        let lua = GoatLua::create()?;
        
        if !path.exists() {
            return Err(anyhow!("Config file: \"{}\" does not exist", path.display()))
        }
        
        let config_script = std::fs::read_to_string(path)?;

        let globals = lua.lua.globals();

        let package: mlua::Table = globals.get("package").map_err(|e| anyhow!("{}", e))?;
        let old_path: String = package.get("path").map_err(|e| anyhow!("{}", e))?;
        package.set(
            "path", 
            format!("{};{}/?.lua", old_path, path.to_string_lossy().to_string())).map_err(|e| anyhow!("{}", e)
        )?;
        
        // The mlua library doesn't seem to be friendly with anyhow so we still need to use map_err 
        // on each Result returning function from them.
        lua.lua.load(&config_script).exec().map_err(|e| anyhow!("Failed to interpret configuration file: \n{}\n", e))?;
        
        let mut config = Config::default();
        
        // libc standards require a lower than 64 length hostname. Unfortunately we need to support 
        // this standard for now. DNS FQDN restrictions have a cap of 255 characters, this might be
        // something we will need to change in the future so IT guys with huge domain name 
        // requirements can use `goat`.
        if config.hostname.len() > 64 {
            return Err(anyhow!("Configuration hostname is too long! Keep it under 64 characters."));
        }
        
        // Validate hostname by POSIX and RFC 1123 standards
        // This regex was generated by ChatGPT.
        let validation_regex = Regex::new(
            r"^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$"
        )?;
        
        if !validation_regex.is_match(&config.hostname) {
            return Err(anyhow!("Configuration hostname doesn't adhere to RFC 1123 standards!"));
        }

        if let Ok(packages_value) = globals.get::<Value>("packages").map_err(|e| anyhow!("{}", e)) {
            if let Some(packages_list) = packages_value.as_table() {
                config.packages = Some(packages_list.sequence_values::<String>()
                        .collect::<Result<Vec<_>, _>>()
                        .map_err(|err| anyhow!("{}", err))?)
            }
        } 
        
        Ok(config)
    }
}